#!/bin/sh

export INTERFACE=${PROBE_INTERFACE:-"lo"}
export ARGS=${PROBE_SRC:-"127.0.0.1"}
export COLOR=${PROBE_COLOR:-1}
export ROOT=${PROBE_ROOT:-1}
export RAINBOW=${PROBE_RAINBOW:-1}
export FLAG=${PROBE_FLAG:-'rainbow'}
export FLAG_BG=${PROBE_FLAG_BG:-0}
export FLAG_BGNAME=${PROBE_FLAG_BGNAME:-'rainbow'}
export FLAG_VERTICAL=${PROBE_FLAG_VERTICAL:-0}

if [ "$(echo $ROOT)" == "1" ] && ! [ "$(whoami)" == "root" ]; then
	echo "Command must be executed by a root user!"
	exit 1
fi

SCRIPT_TYPE=$(basename "$0" | rev | cut -f 1 -d "-" | rev)

if [ "$INTERFACE" == "lo" ] && ! [ -n "$PROBE_INTERFACE" ]; then
	INTERFACE=$(ip -o link show | awk '{if (NR>1 && $3 != "lo:") print $2}' | cut -f 1 -d ":" | head -n 1)
	if [ "$INTERFACE" == "" ]; then
		INTERFACE="lo"
	fi
fi

if [ "$ARGS" == "127.0.0.1" ] && ! [ -n "$PROBE_SRC" ]; then
	ARGS="$(hostname)"
	if [ "$ARGS" == "" ]; then
		ARGS="127.0.0.1"
	fi
fi

export color_schemes=("rainbow" "trans" "queer" "enby" "pansexual" "polysexual" "aroace" "asexual" "aromantic" "agender" "lesbian" "bisexual" "genderfluid")

if [ -n "$1" ]; then
	case "$1" in
		"colors")
			echo "Available color schemes:"
			for element in "${color_schemes[@]}"; do
				echo '	- '"${element}"
			done
			exit 0
			;;
		"log")
			if ! [ -n "$2" ]; then
				echo "Missing log ID."
				exit 404
			fi
			work_path="$HOME/.cache/xaviama/tcp-probe"
			if [ -d "$work_path" ]; then
				if ! [ -f "$work_path/probe-tcp-${SCRIPT_TYPE}-log-$2" ]; then
					echo "Log ID not found."
					exit 404
				fi
				cat "$work_path/probe-tcp-${SCRIPT_TYPE}-log-$2"
				exit 0
			elif [ -d "/tmp" ]; then
				if ! [ -f "/tmp/probe-tcp-${SCRIPT_TYPE}-log-$2" ]; then
					echo "Log ID not found."
					exit 404
				fi
				cat "/tmp/probe-tcp-${SCRIPT_TYPE}-log-$2"
				exit 0
			else
				echo "Based paths not found..."
				exit 404
			fi
			;;
		"rmlog")
			if ! [ -n "$2" ]; then
				echo "Missing log ID."
				exit 404
			fi
			work_path="$HOME/.cache/xaviama/tcp-probe"
			if [ -d "$work_path" ]; then
				if ! [ -f "$work_path/probe-tcp-${SCRIPT_TYPE}-log-$2" ]; then
					echo "Log ID not found."
					exit 404
				fi
				rm -f "$work_path/probe-tcp-${SCRIPT_TYPE}-log-$2"
				exit 0
			elif [ -d "/tmp" ]; then
				if ! [ -f "/tmp/probe-tcp-${SCRIPT_TYPE}-log-$2" ]; then
					echo "Log ID not found."
					exit 404
				fi
				rm -f "/tmp/probe-tcp-${SCRIPT_TYPE}-log-$2"
				exit 0
			else
				echo "Based paths not found..."
				exit 404
			fi
			;;
		"rmlogs")
			work_path="$HOME/.cache/xaviama/tcp-probe"
			if [ -d "$work_path" ]; then
				for element in $(find "$work_path" -type f -name '*'"${SCRIPT_TYPE}"'-log*'); do
					rm -f "$element"
				done
				exit 0
			fi
			if [ -d "/tmp" ]; then
				for element in $(find "/tmp" -type f -name '*'"${SCRIPT_TYPE}"'-log*'); do
					rm -f "$element"
				done
				exit 0
			fi
			;;
		"help")
			echo "Help output of probe-${SCRIPT_TYPE}:"
			echo '	Environment variables:'
			echo '	- `PROBE_COLOR=0/1 | default 1` - set colors for a console'
			echo '	- `PROBE_SRC=<string> | default 127.0.0.1` - set source destination (for `probe-out`)'
			echo '	- `PROBE_DST=<string> | default 127.0.0.1` - set destination (for `probe-in`)'
			echo '	- `PROBE_INTERFACE=<string> | default eth3` - set interface on which `tcpdump` should listen on'
			echo '	- `PROBE_ROOT=0/1 | default 1` - check if running as root'
			echo '	- `PROBE_RAINBOW=0/1 | default 1` - enable rainbow texts'
			echo '	- `PROBE_FLAG=<string> | default rainbow` - set color scheme (list available schemes under `colors` command)'
			echo '	- `PROBE_FLAG_BG=0/1 | default 0` - render flag in background too'
			echo '	- `PROBE_FLAG_BGNAME=<string> | default rainbow` - set name for background flag'
			echo '	- `PROBE_FLAG_VERTICAL=0/1 | default 1` - render flag vertically'
			echo ""
			echo '	Commands:'
			echo '	- `log <ID>` - show log file from ID'
			echo '	- `rmlog <ID>` - remove specific log'
			echo '	- `rmlogs` - remove all logs'
			echo '	- `help` - show help output'
			echo '	- `colors` - show available color schemes'
			echo ""
			echo 'Â© 2023 Chimmie Firefly | Akini License 3.1'
			exit 0
			;;
		*)
			echo "Unknown command!"
			echo "	Type \`$(realpath $0) help\` for help."
			exit 404
			;;
	esac
fi

export time_boot="$(date +%s)"

if [ -d "$HOME" ]; then
	if ! [ -d "$HOME"/.cache/xaviama/tcp-probe ]; then
		mkdir -p "$HOME"/.cache/xaviama/tcp-probe
	fi
	for pids in $(find "$HOME/.cache/xaviama/tcp-probe" -type f -name '*'"${SCRIPT_TYPE}"'-pid*'); do
		actual_pid=$(cat "$pids")
		process_name=$(ps -p $actual_pid -o comm= | grep -oE '[^/]+$')

		if [ -n "$process_name" ]; then
			if ! [ "$process_name" == "probe-out" ]; then
				old_date_pid=$(echo "$pids" | rev | cut -f 1 -d "-" | rev)
				rm -f "$HOME/.cache/xaviama/tcp-probe/probe-tcp-${SCRIPT_TYPE}-pipe-$old_date_pid"
				rm -f "$pids"
			fi
		else
			old_date_pid=$(echo "$pids" | rev | cut -f 1 -d "-" | rev)
			rm -f "$HOME/.cache/xaviama/tcp-probe/probe-tcp-${SCRIPT_TYPE}-pipe-$old_date_pid"
			rm -f "$pids"
		fi
	done
	for logs in $(find "$HOME/.cache/xaviama/tcp-probe" -type f -name '*log*'); do
		date_engine=$(($(echo "$logs" | rev | cut -f 1 -d "-" | rev)))
		date_actual=$(($time_boot))
		division=0
		let "division = date_actual - date_engine"
		if [ $division -gt 86400 ]; then
			rm -f "$logs"
		fi
	done
	export shell_pid="$HOME/.cache/xaviama/tcp-probe/probe-tcp-${SCRIPT_TYPE}-pid-$time_boot"
	export pipe="$HOME/.cache/xaviama/tcp-probe/probe-tcp-${SCRIPT_TYPE}-pipe-$time_boot"
	export logging="$HOME/.cache/xaviama/tcp-probe/probe-tcp-${SCRIPT_TYPE}-log-$time_boot"
else
	export shell_pid="/tmp/probe-tcp-${SCRIPT_TYPE}-pid-$time_boot"
	export pipe="/tmp/probe-tcp-${SCRIPT_TYPE}-pipe-$time_boot"
	export logging="/tmp/probe-tcp-${SCRIPT_TYPE}-log-$time_boot"
fi

echo "$$" > "$shell_pid"
mkfifo "$pipe"
touch "$logging"

exec 3> "$logging"

clear

function shutdown() {
	kill -9 "$tcpdump_pid"
	rm -f "$pipe"
	rm -f "$shell_pid"
	echo "${BCyan}> ${BRed}Shutting down!${NC}"
	exit 0
}

trap "shutdown" SIGTERM SIGINT ERR

function load_colors() {
    if [ $COLOR == 1 ]; then
        LS_COLORS='no=00;38;5;244:rs=0:di=00;38;5;33:ln=00;38;5;37:mh=00:pi=48;5;230;38;5;136;01:so=48;5;230;38;5;136;01:do=48;5;230;38;5;136;01:bd=48;5;230;38;5;244;01:cd=48;5;230;38;5;244;01:or=48;5;235;38;5;160:su=48;5;160;38;5;230:sg=48;5;136;38;5;230:ca=30;41:tw=48;5;64;38;5;230:ow=48;5;235;38;5;33:st=48;5;33;38;5;230:ex=00;38;5;64:*.tar=00;38;5;61:*.tgz=00;38;5;61:*.arj=00;38;5;61:*.taz=00;38;5;61:*.lzh=00;38;5;61:*.lzma=00;38;5;61:*.tlz=00;38;5;61:*.txz=00;38;5;61:*.zip=00;38;5;61:*.z=00;38;5;61:*.Z=00;38;5;61:*.dz=00;38;5;61:*.gz=00;38;5;61:*.lz=00;38;5;61:*.xz=00;38;5;61:*.bz2=00;38;5;61:*.bz=00;38;5;61:*.tbz=00;38;5;61:*.tbz2=00;38;5;61:*.tz=00;38;5;61:*.deb=00;38;5;61:*.rpm=00;38;5;61:*.jar=00;38;5;61:*.rar=00;38;5;61:*.ace=00;38;5;61:*.zoo=00;38;5;61:*.cpio=00;38;5;61:*.7z=00;38;5;61:*.rz=00;38;5;61:*.apk=00;38;5;61:*.gem=00;38;5;61:*.jpg=00;38;5;136:*.JPG=00;38;5;136:*.jpeg=00;38;5;136:*.gif=00;38;5;136:*.bmp=00;38;5;136:*.pbm=00;38;5;136:*.pgm=00;38;5;136:*.ppm=00;38;5;136:*.tga=00;38;5;136:*.xbm=00;38;5;136:*.xpm=00;38;5;136:*.tif=00;38;5;136:*.tiff=00;38;5;136:*.png=00;38;5;136:*.PNG=00;38;5;136:*.svg=00;38;5;136:*.svgz=00;38;5;136:*.mng=00;38;5;136:*.pcx=00;38;5;136:*.dl=00;38;5;136:*.xcf=00;38;5;136:*.xwd=00;38;5;136:*.yuv=00;38;5;136:*.cgm=00;38;5;136:*.emf=00;38;5;136:*.eps=00;38;5;136:*.CR2=00;38;5;136:*.ico=00;38;5;136:*.tex=00;38;5;245:*.rdf=00;38;5;245:*.owl=00;38;5;245:*.n3=00;38;5;245:*.ttl=00;38;5;245:*.nt=00;38;5;245:*.torrent=00;38;5;245:*.xml=00;38;5;245:*Makefile=00;38;5;245:*Rakefile=00;38;5;245:*Dockerfile=00;38;5;245:*build.xml=00;38;5;245:*rc=00;38;5;245:*1=00;38;5;245:*.nfo=00;38;5;245:*README=00;38;5;245:*README.txt=00;38;5;245:*readme.txt=00;38;5;245:*.md=00;38;5;245:*README.markdown=00;38;5;245:*.ini=00;38;5;245:*.yml=00;38;5;245:*.cfg=00;38;5;245:*.conf=00;38;5;245:*.h=00;38;5;245:*.hpp=00;38;5;245:*.c=00;38;5;245:*.cpp=00;38;5;245:*.cxx=00;38;5;245:*.cc=00;38;5;245:*.objc=00;38;5;245:*.sqlite=00;38;5;245:*.go=00;38;5;245:*.sql=00;38;5;245:*.csv=00;38;5;245:*.log=00;38;5;240:*.bak=00;38;5;240:*.aux=00;38;5;240:*.lof=00;38;5;240:*.lol=00;38;5;240:*.lot=00;38;5;240:*.out=00;38;5;240:*.toc=00;38;5;240:*.bbl=00;38;5;240:*.blg=00;38;5;240:*~=00;38;5;240:*#=00;38;5;240:*.part=00;38;5;240:*.incomplete=00;38;5;240:*.swp=00;38;5;240:*.tmp=00;38;5;240:*.temp=00;38;5;240:*.o=00;38;5;240:*.pyc=00;38;5;240:*.class=00;38;5;240:*.cache=00;38;5;240:*.aac=00;38;5;166:*.au=00;38;5;166:*.flac=00;38;5;166:*.mid=00;38;5;166:*.midi=00;38;5;166:*.mka=00;38;5;166:*.mp3=00;38;5;166:*.mpc=00;38;5;166:*.ogg=00;38;5;166:*.opus=00;38;5;166:*.ra=00;38;5;166:*.wav=00;38;5;166:*.m4a=00;38;5;166:*.axa=00;38;5;166:*.oga=00;38;5;166:*.spx=00;38;5;166:*.xspf=00;38;5;166:*.mov=00;38;5;166:*.MOV=00;38;5;166:*.mpg=00;38;5;166:*.mpeg=00;38;5;166:*.m2v=00;38;5;166:*.mkv=00;38;5;166:*.ogm=00;38;5;166:*.mp4=00;38;5;166:*.m4v=00;38;5;166:*.mp4v=00;38;5;166:*.vob=00;38;5;166:*.qt=00;38;5;166:*.nuv=00;38;5;166:*.wmv=00;38;5;166:*.asf=00;38;5;166:*.rm=00;38;5;166:*.rmvb=00;38;5;166:*.flc=00;38;5;166:*.avi=00;38;5;166:*.fli=00;38;5;166:*.flv=00;38;5;166:*.gl=00;38;5;166:*.m2ts=00;38;5;166:*.divx=00;38;5;166:*.webm=00;38;5;166:*.axv=00;38;5;166:*.anx=00;38;5;166:*.ogv=00;38;5;166:*.ogx=00;38;5;166:'
        export LS_COLORS

        # Normal Colors
        export Black=$'\e[0;30m'        # Black
        export Red=$'\e[0;31m'          # Red
        export Green=$'\e[0;32m'        # Green
        export Yellow=$'\e[0;33m'       # Yellow
        export Blue=$'\e[0;34m'         # Blue
        export Purple=$'\e[0;35m'       # Purple
        export Cyan=$'\e[0;36m'         # Cyan
        export White=$'\e[0;37m'        # White

        # Bold
        export BBlack=$'\e[1;30m'       # Black
        export BRed=$'\e[1;31m'         # Red
        export BGreen=$'\e[1;32m'       # Green
        export BYellow=$'\e[1;33m'      # Yellow
        export BBlue=$'\e[1;34m'        # Blue
        export BPurple=$'\e[1;35m'      # Purple
        export BCyan=$'\e[1;36m'        # Cyan
        export BWhite=$'\e[1;37m'       # White

        # Background
        export On_Black=$'\e[40m'       # Black
        export On_Red=$'\e[41m'         # Red
        export On_Green=$'\e[42m'       # Green
        export On_Yellow=$'\e[43m'      # Yellow
        export On_Blue=$'\e[44m'        # Blue
        export On_Purple=$'\e[45m'      # Purple
        export On_Cyan=$'\e[46m'        # Cyan
        export On_White=$'\e[47m'       # White

        export NC=$'\e[m'               # Color Reset
    else
        unset LS_COLORS

        # Normal Colors
        unset Black        # Black
        unset Red          # Red
        unset Green        # Green
        unset Yellow       # Yellow
        unset Blue         # Blue
        unset Purple       # Purple
        unset Cyan         # Cyan
        unset White        # White

        # Bold
        unset BBlack       # Black
        unset BRed         # Red
        unset BGreen       # Green
        unset BYellow      # Yellow
        unset BBlue        # Blue
        unset BPurple      # Purple
        unset BCyan        # Cyan
        unset BWhite       # White

        # Background
        unset On_Black       # Black
        unset On_Red         # Red
        unset On_Green       # Green
        unset On_Yellow      # Yellow
        unset On_Blue        # Blue
        unset On_Purple      # Purple
        unset On_Cyan        # Cyan
        unset On_White       # White

        unset NC               # Color Reset
    fi

}

load_colors

# Trans Flag
export cbow_trans=("BCyan" "BPurple" "BWhite" "BPurple" "BCyan")
export cbow_trans_bg=("On_Cyan" "On_Purple" "On_White" "On_Purple" "On_Cyan")

# Enby Flag
export cbow_enby=("BYellow" "BWhite" "Purple" "Black")
export cbow_enby_bg=("On_Yellow" "On_White" "On_Purple" "On_Black")

# Bisexual Flag
export cbow_bisexual=("BPurple" "BPurple" "Purple" "BBlue" "BBlue")
export cbow_bisexual=("On_Purple" "On_Purple" "On_Purple" "On_Blue" "On_Blue")

# Lesbian Flag
export cbow_lesbian=("BRed" "Red" "BYellow" "BWhite" "Purple" "BPurple" "BPurple")
export cbow_lesbian=("On_Red" "On_Red" "On_Yellow" "On_White" "On_Purple" "On_Purple" "On_Purple")

# Polysexual Flag
export cbow_polysexual=("BPurple" "Green" "BCyan")
export cbow_polysexual=("On_Purple" "On_Green" "On_Cyan")

# Asexual Flag
export cbow_asexual=("Black" "BBlack" "BWhite" "Purple")
export cbow_asexual=("On_Black" "On_Black" "On_White" "On_Purple")

# Pansexual Flag
export cbow_pansexual=("BPurple" "Yellow" "BCyan")
export cbow_pansexual=("On_Purple" "On_Yellow" "On_Cyan")

# Queer Flag
export cbow_queer=("BRed" "Red" "BYellow" "BGreen" "BBlue" "Purple")
export cbow_queer=("On_Red" "On_Red" "On_Yellow" "On_Green" "On_Blue" "On_Purple")

# Aromantic Flag
export cbow_aromantic=("BGreen" "Green" "BWhite" "BBlack" "Black")
export cbow_aromantic=("On_Green" "On_Green" "On_White" "On_Black" "On_Black")

# Aroace Flag
export cbow_aroace=("Yellow" "BYellow" "BWhite" "BCyan" "Cyan")
export cbow_aroace=("On_Yellow" "On_Yellow" "On_White" "On_Cyan" "On_Cyan")

# Agender Flag
export cbow_agender=("Black" "BBlack" "BWhite" "Green" "BWhite" "BBlack" "Black")
export cbow_agender=("On_Black" "On_Black" "On_White" "On_Green" "On_White" "On_Black" "On_Black")

# Genderfluid Flag
export cbow_genderfluid=("BPurple" "BWhite" "Purple" "Black" "Blue")
export cbow_genderfluid_bg=("On_Purple" "On_White" "On_Purple" "On_Black" "On_Blue")

# Rainbow Flag
export cbow_rainbow=("BRed" "Red" "BYellow" "BGreen" "BBlue" "Purple")
export cbow_rainbow_bg=("On_Red" "On_Red" "On_Yellow" "On_Green" "On_Blue" "On_Purple")

function find_cbow_scheme() {
	result="-1"
	count=0
	for element in "${color_schemes[@]}"; do
		if [ "${element}" == "${FLAG}" ]; then
			result="$count"
			break
		fi
		let "count = count + 1"
	done
	echo "$result"
}

export find_flag=$(find_cbow_scheme)
if [ "$find_flag" == "-1" ]; then
	echo "Unknown color scheme \`${FLAG}\`!"
	echo "List available color schemes under \`colors\` command."
	exit 404
fi

export cbow=0
cbow_array="cbow_${FLAG}"
eval "cbow_array=(\"\${$cbow_array[@]}\")"
export cbow_array

if [ "${FLAG_BG}" == "1" ]; then
	cbow_array_bg="cbow_${FLAG_BGNAME}_bg"
	eval "cbow_array_bg=(\"\${$cbow_array_bg[@]}\")"
	export cbow_array_bg
fi

export cbow_size=${#cbow_array[@]}

function color_bow() {
	let "cbow = cbow + 1"
	if [ $cbow == $1 ]; then
		cbow=0
		export cbow
	fi
	export cbow
}

function rainbow() {
	if [ $COLOR == 0 ]; then
		echo "$1"
	else
		if [ $RAINBOW == 0 ]; then
			echo "${BCyan}$1"
		else
			input_text="$1"
			output_text=""
			# Loop over each character in the string
			for (( i=0; i<${#input_text}; i++ )); do
				# Access each character using parameter expansion
				current_char="${input_text:i:1}"
				if [ "$FLAG_VERTICAL" == "1" ]; then
					color_bow $cbow_size
				fi
				if [ "$FLAG_BG" == "1" ]; then
					output_text="${output_text}${!cbow_array_bg[$cbow]}${!cbow_array[$cbow]}${current_char}"
				else
					output_text="${output_text}${!cbow_array[$cbow]}${current_char}"
				fi
			done
			output_text="${output_text}${NC}"
			echo "$output_text"
		fi
	fi
}

echo "${BCyan}> ${BGreen}Session ID${BWhite}: ${BRed}${time_boot}"
echo "${BCyan}> ${BGreen}Config${BWhite}: ${NC}"
echo "${BCyan}>> interface - ${BGreen}${INTERFACE}"
echo "${BCyan}>> hostname~ - ${BGreen}${ARGS}"
echo "${BCyan}>> Check root - ${BGreen}${ROOT}"
echo "${BCyan}>> Colored - ${BGreen}${COLOR}"
echo "${BCyan}>> Type - ${BGreen}${SCRIPT_TYPE}"
echo "${BCyan}> ${BYellow}Please wait${BWhite}, $(rainbow 'loading interface(s)...')${BRed}"

catch_dump=5
worker_type="${BRed}"'[Outgoing]'
worker_type_plain='[Outgoing]'
type_dump="src"
case "${SCRIPT_TYPE}" in
	"out")
		catch_dump=5
		worker_type="${BRed}"'[Outgoing]'
		worker_type_plain='[Outgoing]'
		type_dump="src"
		;;
	"in")
		catch_dump=3
		worker_type="${BGreen}"'[Incoming]'
		worker_type_plain='[Incoming]'
		type_dump="dst"
		;;
	*)
		echo "${BCyan}> ${BRed}Unknown process type!"
		exit 0
		;;
esac

tcpdump -i ${INTERFACE} -n ${type_dump} ${ARGS} | cut -d " " -f ${catch_dump} | cut -d ":" -f 1 > "$pipe" &

export tcpdump_pid=$!

export TCP_LINKS=()
export TCP_AMOUNT=()

function find_array() {
	index=-1
	target="$1"
	count=0
	for element in "${TCP_LINKS[@]}"; do
		if [[ "$element" == "$target" ]]; then
			index=$count
			break
		fi
		let "count = count + 1"
	done
	echo "$index"
}

# Get terminal width (number of columns)
export tttx=$(tput cols)
export tab_x=0
let "tab_x = tttx / 5"
export tab_x=$(($(printf "%.0f" $tab_x)))

# Get terminal height (number of lines)
export ttty=$(tput lines)

function spacing() {
	output=""
	for (( i=1; i<=$1; i++ )); do
		output="${output} "
	done
	echo "$output"
}

center=0
let "center = tttx / 2"
center=$(($(printf "%.0f" $center)))
export center
ip_label="ID:${time_boot}"' IP List '"${worker_type_plain}"
ip_label_size=${#ip_label}
ip_label_size_half=0
let "ip_label_size_half = ip_label_size / 2"
ip_label_size_half=$(($(printf "%.0f" $ip_label_size_half)))

align_center_text=0
let "align_center_text = center - ip_label_size_half - 1"
unset ip_label_size
unset ip_label_size_half
export ip_label="${On_Blue}"$(spacing $align_center_text)"${BGreen}ID${BWhite}:${BRed}${time_boot}${NC} ${BCyan}IP List${NC} ${On_Blue}${worker_type}${NC}${On_Blue}$(spacing $align_center_text)${NC}"
unset align_center_text

export end_label=" ${BPurple}By Chimmie Firefly ${BWhite}|${BRed} OwO ${BWhite}|${BCyan} Config${BWhite}: ${Green}${INTERFACE} ${BWhite}-${Green} ${ARGS} ${BWhite}-${Green} Root-${ROOT}${BGreen}"

function window_resize() {
	# Get terminal width (number of columns)
	export tttx=$(tput cols)
	export tab_x=0
	let "tab_x = tttx / 5"
	export tab_x=$(($(printf "%.0f" $tab_x)))

	# Get terminal height (number of lines)
	export ttty=$(tput lines)

	center=0
	let "center = tttx / 2"
	center=$(($(printf "%.0f" $center)))
	export center
	ip_label="ID:${time_boot}"' IP List '"${worker_type_plain}"
	ip_label_size=${#ip_label}
	ip_label_size_half=0
	let "ip_label_size_half = ip_label_size / 2"
	ip_label_size_half=$(($(printf "%.0f" $ip_label_size_half)))

	align_center_text=0
	let "align_center_text = center - ip_label_size_half - 1"
	unset ip_label_size
	unset ip_label_size_half
	export ip_label="${On_Blue}"$(spacing $align_center_text)"${BGreen}ID${BWhite}:${BRed}${time_boot}${NC} ${BCyan}IP List${NC} ${On_Blue}${worker_type}${NC}${On_Blue}$(spacing $align_center_text)${NC}"
	unset align_center_text

}

trap "window_resize" WINCH

function render_interface() {
	echo "$ip_label"
	echo ""
	count=0
	total_x=10
	for element in "${TCP_LINKS[@]}"; do
		string=" ${element}: ${TCP_AMOUNT[$count]}"
		string_size=${#string}
		tabbing=0
		let "tabbing = tab_x - string_size"
		string="$(spacing $tabbing) ${element}: ${TCP_AMOUNT[$count]}"
		string_size=${#string}
		if [ "$FLAG_BG" == "1" ]; then
			string="${!cbow_array_bg[$cbow]}$(spacing $tabbing) $(rainbow ${element})${!cbow_array_bg[$cbow]}${BWhite}: ${BRed}${TCP_AMOUNT[$count]}"
		else
			string="$(spacing $tabbing) $(rainbow ${element})${BWhite}: ${BRed}${TCP_AMOUNT[$count]}"
		fi
		let "total_x = total_x + string_size"
		echo -n "$string"
		if [ $total_x -gt $tttx ]; then
			echo ""
			total_x=10
			if [ "$FLAG_VERTICAL" == "0" ]; then
				color_bow $cbow_size
			fi
		fi
		let "count = count + 1"
	done
	echo "${NC}"
	echo ""
	echo ""
	echo "$end_label"
}

while IFS= read -r line; do
	result=$(find_array "$line")
	if [ $(echo "$result") == "-1" ]; then
		TCP_LINKS+=("$line")
		TCP_AMOUNT+=(1)
		export TCP_LINKS
		export TCP_AMOUNT
	else
		amount=${TCP_AMOUNT[$(($result))]}
		let "amount = amount + 1"
		TCP_AMOUNT[$(($result))]=$amount
		export TCP_AMOUNT
	fi
	renderer=$(render_interface)
	clear
	echo "$renderer"
done < "$pipe"
